---
title: "Final Project"
author: "Xiaorui Shi & Ruiyang Zhang"
editor: visual
execute:
  warning: false
format: 
  html:
    embed-resources: true
---

## Libraries

```{r}
library(tidyverse)
library(readr)
library(broom)
library(here)
library(tidymodels)
library(srvyr)
library(themis)  
library(tictoc)
library(tune)
```

## Data

```{r}
raw_recs <- readr::read_csv(here("data", "RECS", "recs2020_public_v7.csv")) %>%
  janitor::clean_names()
```

# Preliminary Data Cleaning

## Variable selection

```{r}
recs<- raw_recs %>% 
  select(!starts_with("z")) %>% # drop imputation indicator
  rename(final_nweight = nweight,
         cost = totaldol,
         evhome = evchrghome,
         energyassist = energyasst,
         finishbase = basefin,
         outbulb = lgtoutany,
         lightmore8=lgtinmore8,
         led = lgtinled) %>% 
  select(!starts_with("btu")) %>% 
  select(!starts_with("nweight")) %>% 
  select(!starts_with("dol")) %>% 
  select(!ends_with("btu")) %>% 
  select(!starts_with("totalbtu")) %>% 
  select(!starts_with("kwh")) %>% 
  select(!starts_with("gallon")) %>% 
  select(!starts_with("cufeetng")) %>% 
  select(!starts_with("period")) %>% 
  select(!starts_with("totaldol")) %>% 
  select(-c(regionc, state_fips, state_postal, iecc_climate_code, usehumid, useel, elother,elwater,elwarm,elfood,elcool,dvd,vcr,dbt99,dbt1,crawl,cooktopindt,combodvr,coldma,cellphone,cellar,cablesat,blender,atticfan,atticfin,appother,woodtype,tothsqft,totcsqft,tvonwe2,tvonwe3,tvonwd2,tvonwd3,tvsize2,tvsize3,tvtype2,tvtype3,ugoth,useequipaux,usecoffee,topfront,studio,sqftrange,smartspk,sizrfri2,sepdvr,poolpump,playsta,outlet,oven,ovenfuel,rangefuel,rangeindt,range,othrooms,origwin,nummeal,numtablet,numsmphone,numlaptop,nhafbath,monpool,lpother,locrfri2,intstream,ice,usehumid,numporthum,h2omain,h2oapt,gargheat,gargcool,foother,uprtfrzr,tvaudiosys,freezer,cooktopfuel,cooktop,agerfri2, usecfan, humidtype, dehumtype, usedehum,numportdehum, dwcycle, dryrfuel, heatapt, cwasher,heathome, dntheat, aircond,coolapt,stories)) %>%
  select(!starts_with("ev")) %>% 
  select(!starts_with("energyasst")) %>% 
  select(!starts_with("base")) %>% 
  select(!starts_with("attc")) %>% 
  select(!starts_with("acequip")) %>% 
  select(!starts_with("tvuse")) %>% 
  select(!starts_with("tl")) %>% 
  select(!starts_with("ss")) %>% 
  select(!starts_with("sqftin")) %>% 
  select(!starts_with("outgrill")) %>% 
  select(!starts_with("fuel")) %>% 
  select(!starts_with("more")) %>% 
  select(!starts_with("lgtout")) %>% 
  select(!starts_with("lgtin")) %>% 
  select(!starts_with("intype")) %>% 
  select(!starts_with("equipaux")) %>% 
  select(!starts_with("typerfr")) %>% 
  select(!ends_with("pay"))
```

## Clean missing values

```{r}
# turn <0 to NA
recs <- recs %>% 
  mutate(across(c(typetherm, tvtype1, tvsize1, starts_with("temp"), solar, sizrfri1, sizfreez, sizeofgarage, rooftype, highceil, equipm, washtemp),~ifelse(.<0, NA, .)))

# turn <0 to 0
recs <- recs %>% 
  mutate(across(c(whypowerout, wheatbkt, tvonwe1, tvonwd1, telldays, swimpool, rovenuse, rcookuse, prkgplc1, payhelp, ovenuse, starts_with("num"), starts_with("no"), montub, intdataacc, housefan, heatcntl, geohp, dwashuse, dryruse, coolcntl, cooktopuse, concrete, finishbase, attic, amtmicro, washload),~ifelse(.<0, 0, .)))

# turn <0 to other values
recs <- recs %>% 
  mutate(smartmeter = ifelse(smartmeter<0, 2, smartmeter),
         across(c(equipage, starts_with("age")),~ifelse(.<0, 1,.)))

# turn NA to 0
recs <- recs %>% 
  mutate(medicaldev = ifelse(is.na(medicaldev), 0,medicaldev))
```

# Microsimulation

With a higher annual household energy costs and the inequity among household characteristics, we come up with a new policy initiative aiming to reduce the energy costs of households of low income and high energy costs by providing energy credits. The bullet points are:\
1. Energy credits are only eligible for households with an annual income lower than \$25,000 and a energy cost per capita higher than \$1,293.\
2. Household can receive a credit of \$200 or \$120 based on when their house was built.\
3. Each elderly person can receive a credit of \$600 per year.\
4. If the household has a medical device in use, the household can receive a credit of \$200 per year.\
5. Every one level increase of household income will deduct the credit by \$2,500\*0.05 = \$125.\

## Build a calculator for the new policy

```{r}
#' Calculate energy credit
#'
#' @param cost Annual energy cost
#' @param member Number of household members
#' @param income Household income level
#' @param year Year range the house built
#' @param elderly Number of adults older than 65 in household
#' @param medical Whether uses medical devices at home
#'
#' @returns Annual energy credit
#'
ec_calculator <- function(cost, member,income, year, elderly, medical) {
  avg = cost/member
  modified_income <- pmax(income - 1, 0)
  if (income<8 & avg >=1293) {
    if(year %in% c(1,2,6,7)){
      credit <- pmax(200 + elderly * 600 + medical * 200 - 0.05*2500*modified_income,0)
    }else if(year %in% c(3,4,5)){
      credit <- pmax(120 + elderly * 600 + medical * 200 - 0.05*2500*modified_income,0)
    }else{
      credit<-pmax(elderly * 600 + medical * 200 - 0.05*2500*modified_income,0)
    }
  } 
  return(credit)
}
```

## Apply the calculator to the dataset

```{r}
data_for_calculation <- recs %>% 
  select(cost, nhsldmem, moneypy, yearmaderange, numadult2, medicaldev) %>% 
  rename(member=nhsldmem,
         income=moneypy,
         year=yearmaderange,
         elderly=numadult2,
         medical = medicaldev)

energy_credit <- data_for_calculation %>% 
  mutate(
    credit = pmap_dbl(
      data_for_calculation,
      .f = ec_calculator
    )
  )
```

## Check the policy result

```{r}
micro_recs <- left_join(energy_credit,recs,by=c("cost"="cost","member"="nhsldmem", "income"="moneypy","year"="yearmaderange","elderly"="numadult2","medical"="medicaldev")) %>%
  mutate(avg_cost = cost/member,
         avg_cost_decile = ntile(avg_cost, n = 10)) %>% 
  as_survey_design(weights = final_nweight)

micro_recs %>% 
  group_by(avg_cost_decile, income) %>% 
  summarise(credit = mean(credit)) %>% 
  pivot_wider(names_from = income, values_from = credit)

```

# Further data cleaning

## Turn character and numeric variables to nominal

```{r}
nominal_var <- recs %>% 
  select(-c(washload, tvcolor, totsqft_en, totrooms, cost, tvonwe1, tvonwd1, starts_with("temp"), telldays, sqftest, rovenuse, rcookuse, ovenuse, final_nweight, starts_with("num"), noheatdays, noacdays, nhsldmem, ncombath, montub, micro, lightmore8, hhage, hdd65, hdd30yr_pub, gwt, elperiph, dwashuse, dryruse, door1sum, doeid, desktop, cooktopuse, cdd65, cdd30yr_pub, bedrooms, amtmicro)) %>% 
  colnames()

recs <- recs %>% 
  mutate(across(all_of(nominal_var),~as.factor(.)))
```

```{r}
# check missing values
missing_rate <- recs %>%
  summarize(across(everything(), ~mean(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "missing_rate") %>%
  arrange(desc(missing_rate))
```

## Prepare Data for Machine Learning

```{r}
set.seed(050525)
split <- initial_split(recs, prop = 0.8)
train_data <- training(split)
test_data  <- testing(split)

set.seed(050525)
folds <- vfold_cv(train_data, v = 5)
```

## Linear Model

```{r}
lm_rec <- recipe(cost ~ ., train_data) |>
  update_role(doeid, new_role = "id") %>% 
  step_impute_mean(all_numeric_predictors()) %>% 
  step_impute_mode(all_nominal_predictors()) %>% 
  step_unknown(all_nominal_predictors()) %>% 
  step_dummy(all_nominal_predictors())

lm_mod <- linear_reg() |>
  set_mode(mode = "regression") |>
  set_engine(engine = "lm")

lm_wf <- workflow() |>
  add_recipe(lm_rec) |>
  add_model(lm_mod)

lm_resamples <- lm_wf |>
  fit_resamples(resamples = folds)

lm_resamples |>
  collect_metrics()
```

## Model 1: LASSO

```{r}
# Recipe changed because
# 1. New levels in "rppdtype" NA
# 2. x has missing values
# 3. zero variance

lasso_rec <- recipe(cost ~ ., data = train_data) %>%
  update_role(doeid, new_role = "id") %>%
  step_unknown(all_nominal_predictors()) %>%
  step_dummy(all_nominal_predictors(), one_hot = TRUE) %>%
  step_impute_median(all_numeric_predictors()) %>%
  step_zv(all_predictors()) %>%
  step_normalize(all_numeric_predictors())

lasso_mod <- linear_reg(penalty = tune(), mixture = 1) %>%
  set_mode("regression") %>%
  set_engine("glmnet")

lasso_wf <- workflow() %>%
  add_recipe(lasso_rec) %>%
  add_model(lasso_mod)

lasso_grid <- grid_regular(penalty(), levels = 20)

tic()
lasso_res <- tune_grid(
  lasso_wf,
  resamples = folds,
  grid = lasso_grid,
  metrics = metric_set(rmse, rsq)
)
toc()

collect_metrics(lasso_res)

best_lasso <- select_best(lasso_res, metric = "rmse")

final_lasso_wf <- finalize_workflow(lasso_wf, best_lasso)

final_lasso_fit <- fit(final_lasso_wf, data = train_data)

lasso_coef <- tidy(final_lasso_fit)

lasso_preds <- predict(final_lasso_fit, new_data = test_data) %>%
  bind_cols(test_data %>% select(cost))

metrics(lasso_preds, truth = cost, estimate = .pred)

```

## Model 2: Random Forest

```{r}

rf_rec <- recipe(cost ~ ., data = train_data) %>%
  update_role(doeid, new_role = "id") %>%
  step_unknown(all_nominal_predictors()) %>%
  step_dummy(all_nominal_predictors()) %>%
  step_impute_median(all_numeric_predictors()) %>%
  step_zv(all_predictors())  

rf_mod <- rand_forest(
  mtry = tune(), 
  min_n = tune(), 
  trees = 100
) %>%
  set_engine("ranger", importance = "permutation") %>%
  set_mode("regression")

rf_wf <- workflow() %>%
  add_recipe(rf_rec) %>%
  add_model(rf_mod)

rf_grid <- grid_random(
  mtry(range = c(10, 30)),
  min_n(range = c(2, 20)),
  size = 20
)

set.seed(050525)
tic()
rf_res <- tune_grid(
  rf_wf,
  resamples = folds,
  grid = rf_grid,
  metrics = metric_set(rmse, rsq)
)
toc()

# 6. 查看调参结果
collect_metrics(rf_res)

# 7. 选择最佳参数并拟合最终模型
best_rf <- select_best(rf_res, metric = "rmse")

final_rf_wf <- finalize_workflow(rf_wf, best_rf)
final_rf_fit <- fit(final_rf_wf, data = train_data)

# 8. 在测试集预测并评估性能
rf_preds <- predict(final_rf_fit, new_data = test_data) %>%
  bind_cols(test_data %>% select(cost))

metrics(rf_preds, truth = cost, estimate = .pred)
```
